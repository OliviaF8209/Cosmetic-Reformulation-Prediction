## Notebook 3: Final Model & Actionable Insights

### 1. Final Model Performance
After extensive testing, Logistic Regression with SMOTE proved to be the most reliable model, effectively balancing precision and recall.
Python

import pandas as pd
from sklearn.metrics import precision_recall_curve, auc, classification_report
from sklearn.linear_model import LogisticRegression
from imblearn.over_sampling import SMOTE
from sklearn.model_selection import train_test_split

# Re-run the final model training to generate the metrics
df = pd.read_csv("updated_cosmo_chemicals.csv")
X = df.drop('Reformulated', axis=1)
y = df['Reformulated']
X_numeric = X[['ChemicalAge', 'ProductLifespan', 'HazardScore']].dropna()
y_numeric = y[X_numeric.index]
X_train, X_test, y_train, y_test = train_test_split(X_numeric, y_numeric, test_size=0.2, random_state=42, stratify=y_numeric)
smote = SMOTE(random_state=42)
X_train_smote, y_train_smote = smote.fit_resample(X_train, y_train)

# Final Model
best_model = LogisticRegression(solver='liblinear', random_state=42)
best_model.fit(X_train_smote, y_train_smote)
y_prob = best_model.predict_proba(X_test)[:, 1]
y_pred = best_model.predict(X_test)

# Calculate PR-AUC
precision, recall, _ = precision_recall_curve(y_test, y_prob)
pr_auc_score = auc(recall, precision)

# Display the final classification report
print("Classification Report for Final Model:")
print(classification_report(y_test, y_pred))

print(f"\nFinal PR-AUC Score: {pr_auc_score:.4f}")
Markdown

### 2. Actionable Insights from EDA
This section highlights the key business-level insights I discovered during the exploratory phase of the project, which are crucial for a recruiter to see.
Python

# Code to show correlation between HazardScore and Reformulation (from your notes)
correlation = df[['HazardScore', 'Reformulated']].corr().iloc[0, 1]
print(f"Correlation between Hazard Score and Reformulation: r = {correlation:.2f}")

# Code to visualize product category trends
product_category_counts = df['PrimaryCategory'].value_counts()
plt.figure(figsize=(12, 6))
sns.barplot(x=product_category_counts.index, y=product_category_counts.values)
plt.title('Product Count by Category')
plt.xlabel('Product Category')
plt.ylabel('Count')
plt.xticks(rotation=45, ha='right')
plt.show()

# Code to visualize feature importance (from your notebooks BW3 and BW6)
# Note: This is an example, you can use your actual final model's feature importances.
feature_importances = {'ChemicalAge': 0.7456, 'ChemicalCount': 0.0912, 'ProductLifespan': 0.0389, 'ChemicalCategoryCount': 0.0297, 'Sustainability': 0.0257, 'Safety': 0.0174, 'Efficacy': 0.0073}
sorted_features = sorted(feature_importances, key=feature_importances.get, reverse=True)
sorted_importances = [feature_importances[f] for f in sorted_features]

plt.figure(figsize=(10, 6))
sns.barplot(x=sorted_importances, y=sorted_features)
plt.title('Feature Importance')
plt.xlabel('Importance Score')
plt.ylabel('Features')
plt.show()

# Code to visualize product category trends (from your notebooks)
import matplotlib.pyplot as plt
import seaborn as sns

# Make sure 'df' is loaded from the start of Notebook 3
product_category_counts = df['PrimaryCategory'].value_counts()
plt.figure(figsize=(12, 6))
sns.barplot(x=product_category_counts.index, y=product_category_counts.values)
plt.title('Product Count by Category')
plt.xlabel('Product Category')
plt.ylabel('Count')
plt.xticks(rotation=45, ha='right')
plt.show()

# Code to visualize feature importance (from your notebooks BW3 and BW6)
# Note: This is an example, use your actual final model's feature importances.
feature_importances = {'ChemicalAge': 0.7456, 'ChemicalCount': 0.0912, 'ProductLifespan': 0.0389, 'ChemicalCategoryCount': 0.0297, 'Sustainability': 0.0257, 'Safety': 0.0174, 'Efficacy': 0.0073}
sorted_features = sorted(feature_importances, key=feature_importances.get, reverse=True)
sorted_importances = [feature_importances[f] for f in sorted_features]

plt.figure(figsize=(10, 6))
sns.barplot(x=sorted_importances, y=sorted_features)
plt.title('Feature Importance')
plt.xlabel('Importance Score')
plt.ylabel('Features')
plt.show()
